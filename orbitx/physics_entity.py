import numpy as np

from . import orbitx_pb2 as protos


class PhysicsEntity:
    """A wrapper around protos.Entity.

    Example usage:
    assert PhysicsEntity(protos.Entity(x=5)).x == 5
    assert PhysicsEntity(protos.Entity(x=1, y=2)).pos == [1, 2]

    To add fields, or see what fields exists, please see orbitx.proto,
    specifically the "message Entity" declaration.
    """
    habitat_hull_strength = 50
    spacestation_hull_strength = 100

    def __init__(self, entity: protos.Entity):
        assert isinstance(entity, protos.Entity)
        self.proto = entity

    def __repr__(self):
        return self.proto.__repr__()

    def __str__(self):
        return self.proto.__str__()

    # These are filled in just below this class definition. These stubs are for
    # static type analysis with mypy.
    name: str
    x: float
    y: float
    vx: float
    vy: float
    r: float
    mass: float
    heading: float
    spin: float
    fuel: float
    throttle: float
    attached_to: str
    broken: bool
    artificial: bool

    @property
    def pos(self):
        return np.asarray([self.proto.x, self.proto.y])

    @pos.setter
    def pos(self, x):
        self.proto.x = x[0]
        self.proto.y = x[1]

    @property
    def v(self):
        return np.asarray([self.proto.vx, self.proto.vy])

    @v.setter
    def v(self, x):
        self.proto.vx = x[0]
        self.proto.vy = x[1]

    # temporary solution to detect AYSE, need improvement

    @property
    def dockable(self):
        return self.name == "AYSE"


for field in protos.Entity.DESCRIPTOR.fields:
    # For every field in the underlying protobuf entity, make a
    # convenient equivalent property to allow code like the following:
    # PhysicsEntity(entity).heading = 5

    def fget(self, name=field.name):
        return getattr(self.proto, name)

    def fset(self, val, name=field.name):
        return setattr(self.proto, name, val)

    def fdel(self, name=field.name):
        return delattr(self.proto, name)

    # Assert that there is a stub for the field before setting it.
    setattr(PhysicsEntity, field.name, property(
        fget=fget, fset=fset, fdel=fdel,
        doc=f"Proxy of the underlying field, self.proto.{field.name}"))

# A note about functions with the signature "(self, *, arg1=None, arg2=None"
# there are a lot of float parameters to the upcoming APIs, so I think it's
# best for the callsite to have to specify what argument is what. For example,
# habitat.fuel_cons(throttle=0.2)
# as opposed to
# habitat.fuel_cons(0.2)
# The former is hopefully much clearer, so I think mandatory keyword arguments
# is better in this case.


class Engine(object):
    def __init__(self, *, max_fuel_cons=None, max_thrust=None):
        """
        max_fuel_cons: kg/s consumption of fuel at max throttle
        max_thrust: newtons of force from engine at max throttle
        """
        assert max_fuel_cons is not None
        assert max_thrust is not None
        self._max_fuel_cons = max_fuel_cons
        self._max_thrust = max_thrust  # max acceleration

    def fuel_cons(self, *, throttle=None):
        assert throttle is not None
        return abs(throttle) * self._max_fuel_cons

    def thrust(self, *, throttle: float = None) -> float:
        """
        throttle: unitless float, nominally in the range [0, 1]
        fuel: kg of fuel available for engine to burn
        returns the magnitude of the thrust in Newtons generated by the engine.
        """
        assert throttle is not None
        return throttle * self._max_thrust


class ReactionWheel(object):
    def __init__(self, *, max_spin_change=None):
        """
        max_spin_change: radians/s/s, maximum angular acceleration
        """
        assert max_spin_change is not None
        self._max_spin_change = max_spin_change

    def spin_change(self, *, requested_spin_change=None):
        """
        requested_spin_change: radians/s/s
        returns the requested spin change, bounded by max_spin_change
        """
        assert requested_spin_change is not None
        if requested_spin_change < -self._max_spin_change:
            return -self._max_spin_change
        elif requested_spin_change > self._max_spin_change:
            return self._max_spin_change
        else:
            return requested_spin_change


class Habitat():
    """Static class implementing hab engine and reaction wheel constraints."""
    engine = Engine(max_fuel_cons=4.8, max_thrust=43222)
    rw = ReactionWheel(max_spin_change=1)

    @classmethod
    def spin_change(cls, *, requested_spin_change: float = None) -> float:
        assert requested_spin_change is not None
        return cls.rw.spin_change(
            requested_spin_change=requested_spin_change)

    @classmethod
    def fuel_cons(cls, *, throttle: float = None) -> float:
        assert throttle is not None
        return abs(cls.engine.fuel_cons(throttle=throttle))

    @classmethod
    def thrust(cls, *,
               throttle: float = None, heading: float = None) -> np.ndarray:
        assert throttle is not None
        assert heading is not None
        thrust = cls.engine.thrust(throttle=throttle)
        return thrust * np.array([np.cos(heading), np.sin(heading)])
