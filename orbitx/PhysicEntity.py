import numpy as np

from . import orbitx_pb2 as protos


class PhysicsEntity(object):
    habitat_hull_strength=50
    spacestation_hull_strength=100
    cannot_land=0 #reserved for small astroid, to be changed

    def __init__(self, entity):
        assert isinstance(entity, protos.Entity)
        self.name = entity.name
        self.proto_entity=entity
        #self.pos = np.asarray([entity.x, entity.y])
        #self.r = entity.r
        #self.v = np.asarray([entity.vx, entity.vy])
        #self.m = entity.mass
        #self.spin = entity.spin
        #self.heading = entity.heading
        #self.fuel = entity.fuel
        #self.throttle = entity.throttle
        #self.attached_to = entity.attached_to
        #self.broken = entity.broken
        #self.artificial = entity.artificial
        
    @property
    def pos(self):
        return np.asarray([self.proto_entity.x, self.proto_entity.y])
    @property
    def v(self):
        return np.asarray([self.proto_entity.vx, self.proto_entity.vy])
    @property
    def r(self):
        return self.proto_entity.r
    @property
    def m(self):
        return self.proto_entity.mass

    @property
    def spin(self):
        return self.proto_entity.spin

    @property
    def heading(self):
        return self.proto_entity.heading

    @property
    def fuel(self):
        return self.proto_entity.fuel
    @property
    def throttle(self):
        return self.proto_entity.throttle

    @property
    def attached_to(self):
        return self.proto_entity.attached_to

    @property
    def broken(self):
        return self.proto_entity.broken

    @property
    def artificial(self):
        return self.proto_entity.artificial
    
    @pos.setter
    def pos(self,x):
        self.proto_entity.x=x[0]
        self.proto_entity.y=x[1]
    @v.setter
    def v(self,x):
        self.proto_entity.vx=x[0]
        self.proto_entity.vy=x[1]
    @r.setter
    def r(self,x):
        self.proto_entity.r=x
    @m.setter
    def m(self,x):
        self.proto_entity.mass=x

    @spin.setter
    def spin(self,x):
        self.proto_entity.spin=x

    @heading.setter
    def heading(self,x):
        self.proto_entity.heading=x

    @fuel.setter
    def fuel(self,x):
        self.proto_entity.fuel=x
    @throttle.setter
    def throttle(self,x):
        self.proto_entity.throttle=x

    @attached_to.setter
    def attached_to(self,x):
        self.proto_entity.attached_to=x

    @broken.setter
    def broken(self,x):
        self.proto_entity.broken=x

    @artificial.setter
    def artificial(self,x):
        self.proto_entity.artificial=x
    

    def as_proto(self):
        return protos.Entity(
            name=self.name,
            x=self.pos[0],
            y=self.pos[1],
            vx=self.v[0],
            vy=self.v[1],
            r=self.r,
            mass=self.m,
            spin=self.spin,
            heading=self.heading,
            fuel=self.fuel,
            throttle=self.throttle,
            attached_to=self.attached_to,
            # I don't know if adding bool() is the cleanest solution
            broken=bool(self.broken),
            artificial=bool(self.artificial)
        )


# A note about functions with the signature "(self, *, arg1=None, arg2=None"
# there are a lot of float parameters to the upcoming APIs, so I think it's
# best for the callsite to have to specify what argument is what. For example,
# habitat.fuel_cons(throttle=0.2)
# as opposed to
# habitat.fuel_cons(0.2)
# The former is hopefully much clearer, so I think mandatory keyword arguments
# is better in this case.

class Engine(object):
    def __init__(self, *, max_fuel_cons=None, max_acc=None):
        """
        max_fuel_cons: kg/s consumption of fuel at max throttle
        max_acc: m/s/s acceleration from engine at max throttle
        """
        assert max_fuel_cons is not None
        assert max_acc is not None
        self._max_fuel_cons = max_fuel_cons
        self._max_acc = max_acc  # max acceleration

    def fuel_cons(self, *, throttle=None):
        assert throttle is not None
        return abs(throttle) * self._max_fuel_cons

    def acceleration(self, *, throttle=None):
        """
        throttle: unitless float, nominally in the range [0, 1]
        fuel: kg of fuel available for engine to burn
        returns the amount of linear acceleration generated by the engine.
        """
        assert throttle is not None
        return throttle * self._max_acc


class ReactionWheel(object):
    def __init__(self, *, max_spin_change=None):
        """
        max_spin_change: radians/s/s, maximum angular acceleration
        """
        assert max_spin_change is not None
        self._max_spin_change = max_spin_change

    def spin_change(self, *, requested_spin_change=None):
        """
        requested_spin_change: radians/s/s
        returns the requested spin change, bounded by max_spin_change
        """
        assert requested_spin_change is not None
        if requested_spin_change < -self._max_spin_change:
            return -self._max_spin_change
        elif requested_spin_change > self._max_spin_change:
            return self._max_spin_change
        else:
            return requested_spin_change


class Habitat():
    """Static class implementing hab engine and reaction wheel constraints."""
    engine = Engine(max_fuel_cons=1, max_acc=12)
    rw = ReactionWheel(max_spin_change=1)

    @classmethod
    def spin_change(cls, *, requested_spin_change=None):
        assert requested_spin_change is not None
        return cls.rw.spin_change(
            requested_spin_change=requested_spin_change)

    @classmethod
    def fuel_cons(cls, *, throttle=None):
        assert throttle is not None
        return abs(cls.engine.fuel_cons(throttle=throttle))

    @classmethod
    def acceleration(cls, *, throttle=None, heading=None):
        assert throttle is not None
        assert heading is not None
        acc = cls.engine.acceleration(throttle=throttle)
        return np.cos(heading) * acc, np.sin(heading) * acc
